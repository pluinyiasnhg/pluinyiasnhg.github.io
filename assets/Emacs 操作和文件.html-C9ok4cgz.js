import{_ as d}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as o,b as i,d as l,e as c,o as s}from"./app-CGUvO3Rj.js";const r={};function t(n,e){return s(),a("div",null,[e[0]||(e[0]=o("h1",{id:"前言",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#前言"},[o("span",null,"前言")])],-1)),e[1]||(e[1]=o("p",null,[c("学习 Emacs 内置文档 Emacs tutorial ，结合在线文档 "),o("a",{href:"https://www.gnu.org/software/emacs/tour/index.html",target:"_blank",rel:"noopener noreferrer"},"A Guided Tour of Emacs"),c("。")],-1)),e[2]||(e[2]=o("p",null,[c("学习知乎 Pavinberg 的 "),o("a",{href:"https://zhuanlan.zhihu.com/p/403076883",target:"_blank",rel:"noopener noreferrer"},"专业 Emacs 入门（二）：基础操作"),c(" 和（三）多文件与模式。")],-1)),i(" more "),e[3]||(e[3]=l(`<p>一直想学习 Emacs，但是苦于无法入门。有看过一步步配置出自己的 Emacs 的教程，包括博客教程和视频教程，但学着很不得劲。最后的水平也就记住了退出和保存的快捷键 <code>C-x C-c</code> 和 <code>C-x C-s</code> 。</p><p>我不喜欢 Emacs 的图形化界面，感觉像十年前的前端样式，“不是我喜欢的 Emacs ，直接拒绝”。在终端中输入 <code>emacs -nw</code> ，emacs 就在终端中启动了。</p><p>先过一遍 Emacs 内置的快速指南，快捷键是 <code>C-h t</code> 。如果像我一样不习惯阅读英文，用命令 <code>M-x help-with-tutorial-spec-language</code>，选择一份中文文档进行学习。这里的 <code>M</code> 是 Meta 键，通常是键盘上的 <code>Alt</code> 。</p><figure><img src="https://vip.123pan.cn/1844935313/obsidian/20250918084530894.png" alt="Emacs 快速指南" width="750" tabindex="0" loading="lazy"><figcaption>Emacs 快速指南</figcaption></figure><h1 id="保存和退出" tabindex="-1"><a class="header-anchor" href="#保存和退出"><span>保存和退出</span></a></h1><p>退出 Emacs：<code>C-x C-c</code> 。</p><p>如果需要临时从 Emacs 回到终端，可以不用保存和退出，选择挂起 Emacs：</p><ul><li><code>C-z</code> (suspend-frame) 挂起 Emacs 回到命令行，如果安装了 evil 插件，<code>C-z</code> 会被占用，需要 <code>C-x C-z</code> 才可以挂起。</li><li><code>fg</code> (foreground 的缩写) 将挂起的 Emacs 恢复到前台。</li></ul><p>Emacs 会定期将正在编辑的文件写入一个“自动保存”文件中。自动保存文件的文件名的头尾各有一个“#”字符，比如正在编辑的文件叫“hello.c”，那么它的自动保存文件就叫“#hello.c#”。这个文件会在正常存盘之后被 Emacs 删除。</p><p>打开原来的文件（注意不是自动保存文件）然后输入 <code>M-x recover file</code> 来恢复自动保存文件。</p><p>配置生效：</p><ul><li><code>C-x C-e</code> 测试单行配置</li><li><code>C-M-x</code> 测试整个函数</li><li><code>M-x eval-buffer</code> 加载整个配置文件。常用于在 <code>*scratch*</code> 缓冲区测试代码。</li><li><code>M-x eval-region</code> 执行部分配置</li></ul><h1 id="光标移动" tabindex="-1"><a class="header-anchor" href="#光标移动"><span>光标移动</span></a></h1><p>Emacs 的上下左右移动快捷键要学，因为之前 Vim 的中英文切换让我十分狼狈，以至于养成了“每次输入完中文都会主动切换回英文”的习惯。</p><p>简而言之就是利用 Vim 的模式，插入模式用 Emacs 进行光标移动，普通模式下则用 Vim 移动。</p><ul><li><code>C-f</code> (forward-char) 前移一个字符。</li><li><code>C-b</code> (backward-char) 后移一个字符。</li><li><code>C-p</code> (previous-line) 上移至前一行。</li><li><code>C-n</code> (next-line) 下移至下一行。</li><li>以词为单位： <code>M-b</code> 光标向左移动一个词， <code>M-f</code> 光标向右移动一个词。</li><li>首尾： <ul><li>行：<code>C-a</code> 为移至行首， <code>a</code> 代表 ahead。<code>C-e</code> 为移至行尾， <code>e</code> 代表 end。</li><li>句子： <code>M-a</code> 光标移至句首， <code>M-e</code> 光标移至句尾。</li><li>文件： <code>M-&lt;</code> 移动到文件开头， <code>M-&gt;</code> 移动到文件末尾。</li></ul></li><li>窗口：<code>M-r</code> 按第一次——光标移动到窗口中间行；接着按第二次——光标移动到窗口最上面一行；接着按第三次——光标移动到窗口最下面一行。</li></ul><p>Meta 系列组合键用来操作“由语言定义的单位（比如词、句子、段落）”，而 Ctrl 系列组合键用来操作“与语言无关的基本单位（比如字符、行等等）”。</p><ul><li><code>M-p</code> (Previous <strong>sentence</strong>)：上一句</li><li><code>M-n</code> (Next <strong>sentence</strong>)：下一句</li><li><code>M-a</code> (c-beginning-of-statement)：将光标移动到“一句”的头部</li><li><code>M-e</code> (c-end-of-statement)：将光标移动到“一句”的尾部</li></ul><h1 id="编辑操作" tabindex="-1"><a class="header-anchor" href="#编辑操作"><span>编辑操作</span></a></h1><h2 id="粘贴" tabindex="-1"><a class="header-anchor" href="#粘贴"><span>粘贴</span></a></h2><ul><li>删除字符：<code>&lt;DEL&gt;</code> 删掉光标左侧的字符。想要删掉右侧的字符，按下 <code>C-d</code> 键。</li><li>移除词：<code>M-d</code> 移除光标右边一整个词。<code>M-&lt;DEL&gt;</code> 移除光标左侧一整个词。</li><li>移除右侧直到句子结尾： <code>M-k</code>。</li><li>移除右侧直到行结尾： <code>C-k</code> 。</li><li>选中部分区域：把光标移动到某处，按下 <code>C-SPC</code> ，此时 Emacs 最下方的空行显示 “Mark set“；接着任意移动光标到另一个位置，可以看到半透明的选择框。这就是和平日里使用鼠标进行选择是一样的。</li><li>复制： <code>M-w</code> 复制选中的区域。</li><li>移除： <code>C-w</code> 移除选中的区域。</li></ul><blockquote><p>删除是 delete，移除是 kill。区别在于：被 kill 的文本被 Emacs 记录下来，后续可以重新插入被移除的文本，类似平时用的剪贴功能。</p></blockquote><p>Emacs 内部维护了一个环形“剪贴板历史”，当你想插入之前移除的内容时（即粘贴之前剪切的内容），按下 <code>C-y</code>，这被称为 &quot;yank&quot;，它会将最近一次移除的内容插入回来。</p><ul><li><code>C-y</code> (yank)：召回最近一次移除的内容</li><li><code>M-y</code> (yank-pop)：粘贴历史记录。一次 <code>M-y</code> 召回再前一次被移除的内容，再按一次 <code>M-y</code> 又可以召回再上一次的内容。连续使用 <code>M-y</code> 会回到起始点。插件 <code>counsel</code> 可以辅助这个过程。</li></ul><p>只消除一个字符或者只消除空白的命令，无法用 <code>C-y</code> 插入被移除的字符或空白，比如 <code>&lt;DEL&gt;</code> 和 <code>C-d</code> 。但这也不是绝对的，这两条命令有前缀参数 <code>C-u</code> 时，就变成了”移除“命令。</p><h2 id="撤销" tabindex="-1"><a class="header-anchor" href="#撤销"><span>撤销</span></a></h2><p>撤销（undo）可以恢复删除和移除的文本。移除文本+召回（yank）效果等同“剪贴”。</p><ul><li>撤销（undo）： <code>C-/</code> 或 <code>C-_</code> 或 <code>C-x u</code> 。撤销刚刚的操作。对字符进行编辑例外，例如按了 5 次删除键删除了 5 个字符，按一下撤销即可复原。</li><li>重做（redo）：Emacs 对于历史记录也维护成了一个环。但 Emacs 并没有直接的重做操作，而是先按一下 <code>C-g</code> ，即没有操作，此时再按撤销键时，会撤销上次的“撤销”，相当于重做；也可以理解为按下 <code>C-g</code> 后这个环的移动方向会改变。所以 Emacs 其实不分 undo 和 redo，而是靠改变历史记录的移动方向来控制。插件 <code>undo-tree</code> 可以辅助这一过程。</li></ul><h1 id="标记与跳转" tabindex="-1"><a class="header-anchor" href="#标记与跳转"><span>标记与跳转</span></a></h1><p>标记和点一起界定区域（Region）。</p><ul><li><code>C-x h</code> (mark-whole-buffer)：选中当前缓冲区</li><li><code>M-h</code> (mark-paragraph)：选中当前段落</li></ul><p>在区域的配合下， Narrowing 限制缓冲区（以及编辑）的视图到一个特定区域。像增量搜索和跳转到缓冲区头部/尾部这些命令，也会随之限制在这个特定区域。Narrowing 适用于只想修改某个区域，不想影响到区域以外的缓冲区。</p><ul><li><code>C-x n n</code> (narrow-to-region)：视图从缓冲区到指定区域</li><li><code>C-x n w</code> (widen)：视图从指定区域返回缓冲区</li></ul><p><code>C-SPC</code> 不仅是选中文本这么简单的功能，它的本质是设定一个标记（mark）。Emacs 还有一个标记跳转功能，例如，我们先在文本的第一行，按下两次 <code>C-SPC</code>（这样我们即打了标记，又没有选中文本），然后光标移动到别的位置（甚至以后学过之后，到别的文件），这时候按下 <code>C-x C-SPC</code> 或 <code>C-u C-SPC</code>，即可立刻跳转回刚刚的位置。同样的，有更好用的插件 <code>counsel</code> 可以辅助这一功能。</p><p>想要跳到特定的行，<code>M-g M-g</code> 加行号、回车即可 。</p><p>标记的概念在 Emacs 中有强烈的体现：</p><table><thead><tr><th>当你……</th><th>标记设置在……</th></tr></thead><tbody><tr><td>输入 <code>C-SPC</code></td><td>当前所在位置</td></tr><tr><td>跳转到缓冲区头部或尾部 (<code>M-&lt;</code> 或 <code>M-&gt;</code>)</td><td>跳转前的位置</td></tr><tr><td>退出增量搜索</td><td>搜索前的位置</td></tr><tr><td>召回文本</td><td>召回区域的开始处</td></tr><tr><td>Insert a buffer or file</td><td>插入文本的开始处</td></tr></tbody></table><p>多次使用标记会在 Emacs 内部形成一个环，环中最多保留16个标记。在这16个标记中，通过 <code>C-u C-SPC</code> 进行跳转。</p><h1 id="重复操作" tabindex="-1"><a class="header-anchor" href="#重复操作"><span>重复操作</span></a></h1><p>前缀 <code>C-u</code> (universal-argument) + 数字 + 移动命令，可以起到重复执行指定次数的移动命令。<code>M-[digit]</code> 是 <code>C-u [digit]</code> 的缩写。不过我电脑上已经占用了 <code>M-1</code> <code>M-2</code> <code>M-3</code> 这三个快捷键，所以就用不上了。</p><ul><li><code>C-u 3 C-p</code> 上移3行距离</li><li><code>C-u 10 C-f</code> 右移10个字符距离</li><li><code>C-u C-n</code> 下移<code>4</code>行距离。<code>C-u</code> 不显式指定数字时，隐式指定数字4，用于不确定要移动多远距离时</li></ul><blockquote><p><code>C-u</code> 与 <code>M-x</code> 组合时的 <code>C-u M-x</code> 是基于前缀字符串搜索命令。可以类比我们的键盘上，按下 <code>1</code> 是输入数字 1，但按下 <code>shift+1</code> 得到的是叹号，<code>C-u</code> 就类似 <code>shift</code> 的作用，并且由于可以接数字等额外参数，<code>C-u</code> 非常强大。</p></blockquote><h1 id="页面移动" tabindex="-1"><a class="header-anchor" href="#页面移动"><span>页面移动</span></a></h1><p>接下来的前移后移和居中，适合浏览代码：</p><ul><li><code>C-v</code> (scroll-up-command)：向下翻滚一屏。</li><li><code>M-v</code> (scroll-down-command)：向上翻滚一屏。</li><li><code>C-l</code> (recenter-top-bottom)：光标所在行居中。多按几次，就是“中-上-下”循环</li></ul><h1 id="搜索文本" tabindex="-1"><a class="header-anchor" href="#搜索文本"><span>搜索文本</span></a></h1><h2 id="增量搜索" tabindex="-1"><a class="header-anchor" href="#增量搜索"><span>增量搜索</span></a></h2><p>在缓冲区中进行搜索，可以看作是另一种光标移动操作。安装了 <code>swiper</code> 的话会显示搜索结果列表，更为直观（swiper 和 counsel 是一套插件）。</p><ul><li><code>C-s</code> (isearch-forward)：从光标位置，向前增量搜索</li><li><code>C-r</code> (isearch-backward)：从光标位置，向后增量搜索</li></ul><p>以向前搜索为例，<code>C-s</code> 后接想找的字符串，匹配到结果后，继续按 <code>C-s</code> ，光标会跳转到下一个匹配的字符串。此时，按 <code>C-g</code> ，光标返回初始位置；按 <code>&lt;return&gt;</code> ，光标停留在匹配字符串，此时用 <code>C-x C-x</code> 也能让光标返回初始位置。</p><ul><li><code>C-s C-s</code> ：复用最近一次搜索用到的字符串。比如退出搜索后发现匹配的位置不对，此时可以用该快捷键，而不用重新输入字符串搜索</li><li><code>C-s M-p</code> ：选中搜索历史记录中上一条记录</li><li><code>C-s M-n</code> ：选中搜索历史记录中下一条记录</li><li><code>C-h k C-s</code> ：更多增量搜索相关的命令</li></ul><h2 id="查询替换" tabindex="-1"><a class="header-anchor" href="#查询替换"><span>查询替换</span></a></h2><p>查询替换命令 <code>M-%</code> (query-replace) 会提示输入一个搜索字符串和一个替换内容。然后，对于缓冲区中的每个匹配项，可以选择是否替换搜索字符串。以下是每个提示下可用的选项：</p><ul><li>输入 <code>y</code> 来替换当前匹配项。</li><li>输入 <code>n</code> 来跳到下一个匹配项而不替换。</li><li>输入 <code>q</code> 来退出而不进行任何其他替换。</li><li>输入 <code>.</code> 来替换此匹配项，然后退出。</li><li>输入 <code>!</code> 来不再询问地替换所有剩余匹配项。</li></ul><h2 id="正则搜索" tabindex="-1"><a class="header-anchor" href="#正则搜索"><span>正则搜索</span></a></h2><p>正则表达式是一种简洁的方式，可以通过使用一种特殊的语言来描述你要查找的内容的形式，从而一次性搜索许多不同的字符串。快捷键 <code>C-M-s</code> (isearch-forward-regexp) 用于正则表达式搜索。</p><p>如果你是正则表达式的新手，或者你正在构建一个特别复杂的正则表达式，你可以使用正则表达式构建器 <code>M-x re-builder</code> 。这个命令会弹出一个单独的窗口，你可以在其中测试你的正则表达式，并且在你编辑正则表达式时，原始缓冲区中的任何匹配项都会被突出显示。</p><p>与其逐个匹配，你也可以选择一次性显示所有匹配项。<code>M-x occur</code> 会提示输入正则表达式，然后在单独的缓冲区中显示当前缓冲区中所有匹配该正则表达式的行（以及它们的行号）。点击任何匹配项都会带你到缓冲区中的该行。</p><h1 id="其他小操作" tabindex="-1"><a class="header-anchor" href="#其他小操作"><span>其他小操作</span></a></h1><p><code>C-g</code> 取消命令。命令输入一半，输错了或者不想用了，可以用 <code>C-g</code> (keyboard-quit)中断。特别的，<code>ESC</code> + <code>C-g</code> 会显示组合键未定义，建议多按两次 <code>ESC</code> 取消。</p><p>调字号：放大 <code>C-x C-=</code> 、缩小 <code>C-x C--</code>、重置字号 <code>C-x C-0</code>。</p><p>大小写变换：</p><ul><li><code>M-u</code> (upcase-word)：将光标后一词变为小写。</li><li><code>M-l</code> (downcase-word)：将光标后一词变为大写。</li><li><code>M-c</code> (capitalize-word)：将光标后一词的首字母变成大写。</li></ul><p>交换位置：</p><ul><li><code>C-t</code> (transpose-chars)：交换光标左右两侧的字符</li><li><code>M-t</code> (transpose-words)：交换光标左右两侧的单词</li><li><code>C-x C-t</code> 交换光标所在行和上一行。</li><li>还有交换句子、段落、选择区域等，但没有快捷键。</li></ul><h1 id="获得帮助" tabindex="-1"><a class="header-anchor" href="#获得帮助"><span>获得帮助</span></a></h1><p>Emacs 内置了多种获取帮助的方式。其共有前缀 <code>C-h</code>。</p><ul><li><code>C-h c</code> (describle-key-briefly)：简要描述快捷键功能。</li><li><code>C-h k</code> (describle-key)：详细描述快捷键功能。</li><li><code>C-h f</code> (describle-function)：描述函数。</li><li><code>C-h v</code> (describe-variable)：描述变量。</li><li><code>C-h a</code> (apropos-command)：列出含某一关键词的命令。</li><li><code>C-h d</code> ：列出含某一关键词的符号的文档。</li></ul><blockquote><p><code>C-h c</code> 和 <code>C-h k</code> 根据快捷键确定；<code>C-h x</code> 根据命令名确定。</p></blockquote><ul><li><code>C-h x</code> (describe-command)：解释一个命令</li><li><code>C-h m</code> (describe-mode)：查看当前缓冲区的主模式、副模式</li><li><code>C-h r</code> (info-emacs-manual)：继续学习 Emacs 的权威指南 <a href="https://www.gnu.org/software/emacs/manual/emacs.html" target="_blank" rel="noopener noreferrer">GNU Emacs Manual</a></li><li><code>C-h i</code> (info)：一些 Emacs 功能有自己的、独立的手册 (<code>C-h i d</code>)</li><li><code>C-h ?</code> (help-for-help)：帮助的帮助。列出以上功能，以及其它帮助功能。插件 <code>which-key</code> 可以在敲快捷键给予一定的提示作用</li></ul><h1 id="初识界面" tabindex="-1"><a class="header-anchor" href="#初识界面"><span>初识界面</span></a></h1><p>一些概念：</p><ul><li>菜单栏，在 Frame 的最上方。默认包括了 File、Edit……等等下拉菜单。在终端中不能用鼠标时，需要用 <code>menu-bar-open</code> 命令打开，对应快捷键 <code>&lt;f10&gt;</code> 。此外还有一个 <code>M-\\tilde{}</code> 键（对应命令 <code>tmm-menu</code> ）可以从下方展开互动界面打开菜单。</li><li>工具栏，只在图形界面时可以使用。通常会关掉工具栏：在配置文件中加入代码 <code>(tool-bar-mode -1)</code> 。</li><li>Window：Tool bar 以下、Echo area 以上这一整个区域，就是 Window，即窗口。我们日常称为窗口的在 Emacs 中被称为 Frame，而 Frame 内的核心区域才被称为 Window。</li><li>Frame：如果用图形界面打开 Emacs 程序，那么一整个程序窗口被称为 Frame，如果打开了多个窗口就有多个 Frame；如果在终端内打开 Emacs，那么 Emacs 所占据的整个终端的界面被称为 Frame。</li><li>状态栏（mode line）：回显区正上方的一行，显示当前 Buffer 的一些信息，包括了文件编码、是否修改、当前 Buffer 名、光标所在位置占全文百分比、行号等等。</li><li>回显区（echo area)：屏幕最下面一行，用以打印各种简短的信息。</li><li>在输入 <code>M-x</code> 后、 <code>C-x b</code> 后在 Echo area 显示的等待输入的区域被称为 <code>Minibuffer</code>， 它们的输入方式是共通的，都可以用相同的补全机制等。</li><li>缓冲区（buffer）：为了方便理解，可以简单看作文件（file）。</li><li>Scroll bar ：图形界面时 Window 的最右侧有一滚动条。在配置中加入 <code>(when (display-graphic-p) (toggle-scroll-bar -1))</code> 表示关闭滚动条。</li><li>Cursor ：光标是一个 1 字符宽的方块，但其真正表达的位置是其左侧的长边，即两字符之间。</li><li>Point ：光标所在的位置称为 Point。区别于光标的是，光标有且只有一个，但 Point 是针对 Buffer 的，每个 Buffer 都有一个 Point。许多命令的触发都要读取 Point 信息。在多数情况下，用户感知到的是 cursor，而实际编辑操作基于 point 。</li></ul><blockquote><p>快捷键 <code>&lt;DEL&gt;</code> 指的是退格键 Backspace，而不是 Delete 键。</p></blockquote><h1 id="打开多文件" tabindex="-1"><a class="header-anchor" href="#打开多文件"><span>打开多文件</span></a></h1><ul><li><code>C-x C-f</code> (helm-find-files)：打开文件。若打开一个不存在的文件，则等同于创建一个新文件</li><li><code>C-x C-s</code> (save-buffer)：保存文件（当前缓冲区）。保存文件时，Emacs 默认会为文件备份，例如打开了 <code>names.txt</code> 后会出现 <code>names.txt~</code></li></ul><p>关闭文件备份的方法：<code>M-x customize-variable &lt;Return&gt; make-backup-files &lt;Return&gt;</code> 或  <code>(setq make-backup-files nil)</code> 。</p><p>Emacs 可以打开多个文件，同样使用 <code>C-x C-f</code> 打开即可。 但是你如果打开了第二个文件，便会发现第一个文件就消失不见了，应当去哪里找呢？事实上，所有打开的文件都会被放入一个被称为 Buffer 的对象中，当打开了第二个文件时，第一个文件所在的 Buffer 会切入后台，而第二个文件的 Buffer 会占据当前的 Window。Buffer 的名字显示在 Mode line 中间，通常是文件名本身。</p><p>Emacs 也可以用这个方式打开目录（文件夹），会显示出目录内的文件，可以用光标选择想打开的文件。</p><h1 id="buffer-的切换" tabindex="-1"><a class="header-anchor" href="#buffer-的切换"><span>Buffer 的切换</span></a></h1><p>每个已打开的文件都是一个缓冲区。因此切换缓冲区，等同于打开一个已经打开的文件。</p><ul><li><code>C-x C-b</code> (list-buffers)：列出缓冲区，仅能查看。</li><li><code>C-x b</code> (helm-list-buffers)：列出缓冲区，可以切换。</li><li><code>C-x s</code> (save-some-buffers)：保存所有缓冲区（所有文件）。</li><li><code>C-x k</code> (kill-buffer)：关闭 Buffer。</li></ul><p>切换 Buffer 最简单的方法是使用 <code>C-x b</code> ，输入 Buffer 的名字后按回车即可切换。</p><p>显然 Buffer 多了会记不住名字也不便于管理，于是可以使用第二个方法 <code>C-x C-b</code> ，此时会弹出一个 Window，名为 <code>*Buffer List*</code> ，列出了当前所打开的所有 Buffer。其中可以看到多个以星号 <code>*</code> 开头结尾的 Buffer，那些都是 Emacs 用于输出一些信息的 Buffer，并不是由于打开文件而产生。Buffer 开头如果是 <code>%</code>，表示这个 Buffer 被修改过而没有保存。</p><p>在 <code>*Buffer List*</code> 中：</p><ul><li>按问号（ <code>?</code> ）可以显示帮助。</li><li><code>q</code> 退出。</li><li><code>d</code> 标记一个 Buffer 打算关闭， <code>s</code> 标记一个 Buffer 打算保存， <code>u</code> 取消标记， <code>x</code> 执行刚刚标记过的删除和保存操作。</li><li>在这里上下移动光标也不需要 <code>C-p</code> 和 <code>C-n</code> ，直接按 <code>p</code> 和 <code>n</code> 即可。</li></ul><h1 id="多窗格" tabindex="-1"><a class="header-anchor" href="#多窗格"><span>多窗格</span></a></h1><p>Emacs 可以像 tmux 那样同时打开两个文件相互参照对比。</p><ul><li><code>C-x 0</code> (delete-window)：关闭光标所在处的窗格。</li><li><code>C-x 1</code> (maximize-window)：只保留光标所在的窗格。其它窗格的 Buffer 依然没有关闭。</li><li><code>C-x 2</code> (split-window-below)：向下分割出一个窗格。</li><li><code>C-x 3</code> (split-window-right)：向右分割出一个窗格。</li><li><code>C-x o</code> (other-window)：切换光标到下一个窗格。</li></ul><blockquote><p>不管是向下分，还是向右分，光标还是位于原来的窗格。切换窗格时，多按几次 <code>C-x o</code>，就能循环遍历所有窗格。</p></blockquote><p>光标可以不切换到新窗格，就能在新窗格中滚动页面。当前窗格滚动快捷键是 <code>C-v</code> 和 <code>M-v</code> ，新窗格是 <code>C-M-v</code> (scroll-other-window) 和 <code>C-M-S-v</code> 。这两个快捷键很重要，平时翻阅帮助文档时候，就是创建一个新窗格，在新窗格内查看文档。</p><p>与窗口的区别：终端中的 Emacs 只有一个窗口，即当前的终端窗口；GUI 界面的 Emacs 可以创建多个窗口。每个窗口有单独的菜单栏、滚动条，就像平时的应用多开。</p><p>开一个新窗口并打开新文件这个需求很常见，对此如果只有以上快捷键，需要先 <code>C-x 3</code> 分割出一个窗口，<code>C-x o</code> 切换到新窗口，<code>C-x C-f</code> 打开新文件，过于繁琐。对此 Emacs 提供了一个快捷键 <code>C-x 4 f</code> 来实现“在另一个窗口打开新的文件，如果只有一个窗口就分割成两个”的效果。</p><p>此外，还有 <code>C-x 4 b</code> 表示“在另一个窗口切换到另一 Buffer，如果只有一个窗口就分割成两个” 。<code>C-x 4 d</code> 表示 “在另一个窗口打开目录，如果只有一个窗口就分割成两个”。</p><blockquote><p>可以总结出 <code>C-x 4</code> 为前缀时，就表达“在另一个窗口做……“。</p></blockquote><h1 id="多-frame" tabindex="-1"><a class="header-anchor" href="#多-frame"><span>多 Frame</span></a></h1><ul><li><code>C-x 5 2</code> 打开一个新的 Frame。</li><li><code>C-x 5 f</code> 在一个新的 Frame 打开文件。</li><li><code>C-x 5</code> 和 <code>C-x 4</code> 基本类似，只是前者在 Frame 间操作，后者在 Window 间操作。</li></ul><p>多 Frame 在终端打开的 Emacs 上没法使用，而且多个 Frame 之间切换很麻烦，通常我的桌面应用不止有两个 Emacs Frame，还有浏览器、IDE、文档等，切换应用十分不方便。</p><h1 id="模式" tabindex="-1"><a class="header-anchor" href="#模式"><span>模式</span></a></h1><p>Emacs 的核心要素之一就是模式（mode）。一个模式就对应着一组环境，不同模式可以分别进行配置，应对不同的场景。例如，编写 C++ 代码时就对应 <code>c++-mode</code> ，编写 Python时使用 <code>python-mode</code> 。在不同的语言的 mode 中，编译、执行的方式都是不同的，这样只要事先定义好 mode，就可以在使用过程中方便切换各种需求场景。</p><h2 id="主模式" tabindex="-1"><a class="header-anchor" href="#主模式"><span>主模式</span></a></h2><p>主模式用于根据缓冲区的内容自定义外观和可用功能。Emacs自带了数十种主要模式，用于编辑常用编程语言、标记语言和配置文件格式。这些主要模式告诉 Emacs 如何：</p><ul><li>正确缩进代码</li><li>进行语法高亮</li><li>区分函数边界</li><li>调用代码要求的解释器，编译器或调试器</li></ul><p>主模式默认根据 Buffer 的文件类型来选择，一个 Buffer 只能对应一个主模式。例如，Emacs 发现你打开了 .cpp 为后缀的文件，就会把 Buffer 自动设置成 c++-mode ，最直观的区别是 Emacs 为不同语言的源码提供了不同的语法高亮。 主模式的名字会显示在 Mode line 上。</p><h2 id="次模式" tabindex="-1"><a class="header-anchor" href="#次模式"><span>次模式</span></a></h2><p>同一个 Buffer 可以有多个次模式，次模式可以进一步调整、增加一些配置。通常来说，插件都是靠次模式来起作用的。一般每个次模式代表一个附加功能，比如语法检查（flymake）和自动补全（company）。</p><ul><li><code>M-x auto-fill-mode</code> ：一行超过70个字符，则自动换行</li><li><code>M-x flyspell-mode</code> ：高亮拼错的单词</li><li><code>M-x follow-mode</code> ：在两个并排显示的窗口共用一个缓冲区时，跟随模式会强制它们一起滚动，使得第二个窗口中显示的文本紧跟在第一个窗口中的文本之后</li></ul><p>一些次模式的影响范围是全局的，即不局限于某个缓冲区，是针对整个编辑器的，如：</p><ul><li><code>M-x incomplete-mode</code> ：随着输入，显示补全</li><li><code>M-x iswitchb-mode</code> ：用 <code>C-x b</code> 切换缓冲区时，会显示所有缓冲区的名字</li></ul><p><code>C-h m</code> 描述了已激活的主模式和次模式，通常会列出在该模式下有用的重要命令，这在学习使用新模式时非常有帮助。</p><h2 id="mode-hook" tabindex="-1"><a class="header-anchor" href="#mode-hook"><span>mode hook</span></a></h2><p>每一个主模式都对应着一个 Mode hook，Mode hook 的作用是当启动一个主模式时，自动执行一些已经“挂钩”到这个主模式的函数或次模式。由此，我们可以自由地向一个主模式上挂上各种功能，在启动这个主模式时就可以自动跟随着一起启动。</p><p>例如，我们希望在主模式“文本文件模式” <code>text-mode</code> 时启动次模式“检查拼写” <code>flyspell-mode</code> ，我们就可以这样写配置：</p><div class="language-lisp line-numbers-mode" data-highlighter="shiki" data-ext="lisp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-lisp"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;; 打开 txt 文件时，会自动开启检查拼写功能</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(add-hook </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">text-mode-hook </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">flyspell-mode)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>text-mode</code> 是基于文本的文件的一个主模式，有一些其它主模式是由它派生，例如 <code>html-mode</code> 。各种编程语言对应的主模式都是由编程模式 <code>prog-mode</code> 派生。</p><p>那么如果我们希望在任何编程语言时都有一些共同需要的功能，例如编程时我们希望有代码块折叠功能，就为 <code>prog-mode-hook</code> 挂上相应功能就好。</p><div class="language-lisp line-numbers-mode" data-highlighter="shiki" data-ext="lisp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-lisp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(add-hook </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">prog-mode-hook </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">#&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">hs-minor-mode)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>上面代码的 <code>#&#39;</code> 是 <strong>function quote</strong>（函数引用）的简写符号。<code>#&#39;hs-minor-mode</code> 等价于 <code>(function hs-minor-mode)</code> 。</p></blockquote><h1 id="目录操作" tabindex="-1"><a class="header-anchor" href="#目录操作"><span>目录操作</span></a></h1><p><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html" target="_blank" rel="noopener noreferrer">Dired</a>，即 Directory Editor，是 Emacs 自带的用以处理目录和文件的功能。常见的操作例如删除文件、将文件从一处拷贝至另一处，更高级的操作如对比两个文件的异同、更改权限、链接文件等等，都可以通过 Dired 实现。</p><ul><li><code>C-x C-f</code> 输入一个目录就会进入 Dired。</li><li>更标准的方式是按 <code>C-x d</code> 或调用 <code>M-x</code> <code>dired</code> 命令然后输入一个目录的名字启动。</li><li>当已经打开了一个文件时，输入 <code>C-x C-j</code> 可以打开当前文件所在的目录。</li></ul><p>Dired 会把目录下的文件都列出来，随后用户可以对文件进行操作。此时可以按下 <code>h</code> （Help）来打开帮助，读者可以翻到下面的 &quot;Keybindings&quot;，里面列出了所有在 Dired 中可以使用的命令。</p><p>Dired 基本操作逻辑为，通过光标上下移动（此时不需要按 <code>Ctrl</code> 而直接按 <code>p</code> 和 <code>n</code> 就可以上下移动光标）到相应文件上，按下一个命令快捷键来对该文件调用命令。想要批量操作，只需要按 <code>m</code> （Mark）就可以选择，按 <code>u</code> （Unmark） 来取消选择。批量删除时，按 <code>d</code> （Delete）标记删除，按 <code>x</code> （Execute）执行删除。</p><h1 id="杂项" tabindex="-1"><a class="header-anchor" href="#杂项"><span>杂项</span></a></h1><h2 id="键盘宏" tabindex="-1"><a class="header-anchor" href="#键盘宏"><span>键盘宏</span></a></h2><p>键盘宏是一种记住固定按键序列以便后续重复使用的方法。它们对于自动化一些枯燥的编辑任务很有用。</p><ul><li><code>F3</code> (kmacro-start-macro-or-insert-counter)：开始录制宏</li><li><code>F4</code> (kmacro-end-or-call-macro)：停止录制宏，或者播放宏一次</li><li><code>M-5 F4</code> ：播放宏5次</li><li><code>M-0 F4</code> ：反复播放宏直到它失败</li></ul><h2 id="快捷键拓展" tabindex="-1"><a class="header-anchor" href="#快捷键拓展"><span>快捷键拓展</span></a></h2><p>Emacs 的命令就像天上的星星，数也数不清。把它们都对应到 Ctrl 和 Meta 组合键上显然是不可能的。Emacs 用扩展命令来解决这个问题，扩展命令有两种风格：</p><ul><li><code>C-x</code> ：字符扩展。 <code>C-x</code> 之后输入另一个字符或者组合键</li><li><code>M-x</code> ：命令名扩展。 <code>M-x</code> 之后输入一个命令名</li></ul><h2 id="递归编辑" tabindex="-1"><a class="header-anchor" href="#递归编辑"><span>递归编辑</span></a></h2><p>递归编辑状态由位于状态栏的方括号所指示，其中包含了用小括号来指明的模式名称。比如说，你有时可能会看到 <code>[(Fundamental)]</code>，而不是 <code>(Fundamental)</code> 。</p><p>不能用 <code>C-g</code> 退出递归编辑，而应该用 <code>ESC ESC ESC</code> 。这条命令还可以关闭多余的窗格。</p><h2 id="软件仓库" tabindex="-1"><a class="header-anchor" href="#软件仓库"><span>软件仓库</span></a></h2><ul><li><code>M-x list-packages</code> 可浏览所有可安装的软件包。这个命令显示的界面中可以安装和卸载软件包，以及查看软件包的简介。</li><li><code>M-x package-install</code> 下载插件。</li><li><code>M-x package-remove</code> 卸载插件。</li><li><code>M-x package-refresh-contents</code> 刷新插件市场。有时候插件下载失败，是因为插件市场太久没更新，插件下载链接失效了。</li></ul><h2 id="版本控制" tabindex="-1"><a class="header-anchor" href="#版本控制"><span>版本控制</span></a></h2><p>Emacs 帮助您操作和编辑存储在版本控制中的文件。Emacs 支持 CVS、Subversion、bzr、git、hg以及其他系统，但它提供了一个统一的接口，称为 VC。</p><ul><li><code>C-x v v</code> (vc-next-action)：提交当前文件，并给出日志信息</li><li><code>C-x v =</code> (vc-diff)：显示当前文件所做的更改的差异</li><li><code>C-x v ~</code> (vc-revision-other-window)：提示输入版本号，并在另一个窗口中显示当前文件的该版本</li><li><code>C-x v g</code> (vc-annotate)：显示文件的注释版本，其中每行显示该行最后一次更改的提交记录和更改者。在任何一行上，<code>L</code> 查看该提交的日志消息，<code>D</code> 查看相关的差异</li><li><code>C-x v l</code> (vc-print-log)：显示文件先前更改的日志。当光标位于特定日志条目上时，按 <code>d</code> 查看与此更改相关的 diff ，按 <code>f</code> 查看该文件的版本</li></ul><h2 id="编辑远程文件" tabindex="-1"><a class="header-anchor" href="#编辑远程文件"><span>编辑远程文件</span></a></h2><p>利用 Emacs 的 Tramp 功能，无须在远程安装 Emacs，在本地的 Emacs 上就能编辑远程文件，仿佛远程文件就在本地一样。本地的 Emacs 通过 SSH、FTP 等方式获取到远程文件，并在远程保存更改。</p><h2 id="emacs-服务器" tabindex="-1"><a class="header-anchor" href="#emacs-服务器"><span>Emacs 服务器</span></a></h2><p>通过 Emacs 打开一个文件，新打开的窗口通常需要重新加载一遍配置，这十分不方便。如果此时已经有一个 Emacs 实例，那么可以用 <code>emacsclient</code> 将新打开的窗口连接到该实例上。</p><h2 id="与常用工具集成" tabindex="-1"><a class="header-anchor" href="#与常用工具集成"><span>与常用工具集成</span></a></h2><ul><li><code>M-x shell</code> ：切换到名为 <code>*shell*</code> 的 shell 缓冲区，若不存在，则创建并切换过去</li><li><code>M-x compile</code> ：调用 <code>make</code> 并在新缓冲区中显示输出</li><li><code>M-x gdb</code> ：在一个新缓冲区中调用 <code>gdb</code></li><li><code>M-x man</code> ：等同于在 shell 中查看 man 文档，比如 <code>man unzip</code></li><li><code>M-x calendar</code> ：打开日历</li><li><code>M-x calculator</code> ：打开计算器</li><li><code>M-x lunar-phases</code> ：显示即将到来的月相</li></ul><h2 id="迁移到-emacs" tabindex="-1"><a class="header-anchor" href="#迁移到-emacs"><span>迁移到 Emacs</span></a></h2><p>在 Windows 中，核心编辑命令是 <code>C-z</code>、<code>C-x</code>、<code>C-c</code> 和 <code>C-v</code>。不幸的是，这些键在 Emacs 中经常用于其他目的（挂起、前缀键、前缀键和翻页）。在选项菜单中打开“CUA 模式”，可以将这些键恢复为撤销、剪切、复制和粘贴。</p><p>对于 Vim 用户，Viper (<code>M-x viper-mode</code>) 是一组在 Emacs 中模拟 vim 编辑行为的模式。它提供了不同级别的 vim 兼容性，具体取决于你希望你的 Emacs 有多像 vim。</p><h1 id="尾声" tabindex="-1"><a class="header-anchor" href="#尾声"><span>尾声</span></a></h1><p>把 Emacs 内置的快速指南过了一遍，GNU Emacs 官网上的文档没来得及看。接下来我要去看看 Emacs 的一款主题 Spacemacs。</p>`,149))])}const m=d(r,[["render",t]]),u=JSON.parse('{"path":"/tools/note/Emacs%20%E6%93%8D%E4%BD%9C%E5%92%8C%E6%96%87%E4%BB%B6.html","title":"Emacs 操作和文件","lang":"zh-CN","frontmatter":{"title":"Emacs 操作和文件","date":"2025-09-18T00:00:00.000Z","tags":["编辑器","Emacs"],"category":["代码效率"],"description":"学习 Emacs 内置文档 Emacs tutorial ，结合在线文档 A Guided Tour of Emacs。 学习知乎 Pavinberg 的 专业 Emacs 入门（二）：基础操作 和（三）多文件与模式。","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Emacs 操作和文件\\",\\"image\\":[\\"https://vip.123pan.cn/1844935313/obsidian/20250918084530894.png\\"],\\"datePublished\\":\\"2025-09-18T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-23T09:29:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"庸碌无常\\",\\"url\\":\\"https://pluinyiasnhg.top\\"}]}"],["meta",{"property":"og:url","content":"https://pluinyiasnhg.top/tools/note/Emacs%20%E6%93%8D%E4%BD%9C%E5%92%8C%E6%96%87%E4%BB%B6.html"}],["meta",{"property":"og:site_name","content":"庸碌无常的博客"}],["meta",{"property":"og:title","content":"Emacs 操作和文件"}],["meta",{"property":"og:description","content":"学习 Emacs 内置文档 Emacs tutorial ，结合在线文档 A Guided Tour of Emacs。 学习知乎 Pavinberg 的 专业 Emacs 入门（二）：基础操作 和（三）多文件与模式。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://vip.123pan.cn/1844935313/obsidian/20250918084530894.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-23T09:29:55.000Z"}],["meta",{"property":"article:tag","content":"Emacs"}],["meta",{"property":"article:tag","content":"编辑器"}],["meta",{"property":"article:published_time","content":"2025-09-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-23T09:29:55.000Z"}]]},"git":{"createdTime":1766482195000,"updatedTime":1766482195000,"contributors":[{"name":"pluinyiasnhg","username":"pluinyiasnhg","email":"pluinyiasnhg@gmail.com","commits":1,"url":"https://github.com/pluinyiasnhg"}]},"readingTime":{"minutes":25.14,"words":7541},"filePathRelative":"tools/note/Emacs 操作和文件.md","excerpt":"\\n<p>学习 Emacs 内置文档 Emacs tutorial ，结合在线文档 <a href=\\"https://www.gnu.org/software/emacs/tour/index.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">A Guided Tour of Emacs</a>。</p>\\n<p>学习知乎 Pavinberg 的 <a href=\\"https://zhuanlan.zhihu.com/p/403076883\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">专业 Emacs 入门（二）：基础操作</a> 和（三）多文件与模式。</p>\\n","autoDesc":true}');export{m as comp,u as data};
