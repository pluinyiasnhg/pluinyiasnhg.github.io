import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,a as s,b as n,d as t,e as a,o as d}from"./app-C444sVTC.js";const h={};function p(c,i){return d(),l("div",null,[i[0]||(i[0]=s("h1",{id:"前言",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#前言"},[s("span",null,"前言")])],-1)),i[1]||(i[1]=s("p",null,[a("Evil 是一个强大的 Vim 模拟，可以让 Vim 用户更容易过渡到 Emacs 使用上。从我个人使用体验来看，Vim 的模式设计十分好用，快捷键也更加精简，比如 "),s("code",null,"h、j、k、l"),a(" 移动方式怎么看都要比 "),s("code",null,"C-b C-p C-n C-f"),a(" 好使。能把 Vim 知识迁移过来重复利用，也是一方面原因。")],-1)),n(" more "),i[2]||(i[2]=t(`<h1 id="evil-vim-文档" tabindex="-1"><a class="header-anchor" href="#evil-vim-文档"><span>Evil vim 文档</span></a></h1><figure><img src="https://vip.123pan.cn/1844935313/obsidian/20250922090103771.png" alt="附送一张 Vim 键盘图" width="700" tabindex="0" loading="lazy"><figcaption>附送一张 Vim 键盘图</figcaption></figure><h2 id="按键风格" tabindex="-1"><a class="header-anchor" href="#按键风格"><span>按键风格</span></a></h2><p><code>C-z</code> 控制 Spacemacs 两种按键风格的切换。比如在 Vim 风格键位中可以用 <code>&lt;ESC&gt;</code> 回到普通模式，但在 Emacs 风格键位中，<code>&lt;ESC&gt;</code> 做不到模式切换。</p><p>Evil vim 普通模式下，除了继承了 Vim 中的上下左右、前移一屏、后移一屏，还保留了 Emacs 中我喜欢用的 <code>C-l</code> ，效果是将光标所在行居中、居于最上、居于最下。虽然 Vim 的 <code>zz</code> 也可以实现居中，但功能还是少了点。</p><h2 id="相反动作" tabindex="-1"><a class="header-anchor" href="#相反动作"><span>相反动作</span></a></h2><p>圆满了，找到 <code>e</code> 的“反义词”了——其他反义词也顺手记录下：</p><ul><li><code>w</code> ：至单词末尾（反向动作： <code>b</code> ）</li><li><code>e</code> ：至单词末位字符（反向动作： <code>ge</code> ）</li><li><code>$</code> ：至行尾（反向动作： <code>0</code> 或 <code>^</code> ）</li><li><code>ce</code> ：更改一个单词的部分</li><li><code>p</code> ：这会将被删除的文本放置（put）在光标之后，若被删的是某一行，它会出现在光标的下一行（反向动作：<code>P</code> ）</li><li><code>/</code> ：向下搜索（反向动作：<code>?</code> ）</li><li><code>f</code> ：行内向前搜索（反向动作：<code>F</code> )</li><li><code>t</code> ：同 f ，但移动位置总是离目标差一个字符（反向动作：<code>T</code> ）</li></ul><p>Evi 默认为全小写的搜索忽略大小写。如果需要大小写敏感，可在末尾加 <code>\\C</code> 。</p><h2 id="批量替换" tabindex="-1"><a class="header-anchor" href="#批量替换"><span>批量替换</span></a></h2><ul><li><code>:s/old/new</code> ：替换<strong>行内第一个</strong>匹配对象</li><li><code>:s/old/new/g</code> ：替换<strong>行内全局</strong>（global）范围的对象</li><li><code>:#,#s/old/new/g</code> ：替换<strong>两行之间</strong>的所有匹配对象</li><li><code>:%s/old/new/g</code> ：替换<strong>整个缓冲区</strong>的所有匹配对象</li><li><code>:%s/old/new/gc</code> ：为了每次询问是否确认，添加 <code>c</code></li></ul><h2 id="开头命令" tabindex="-1"><a class="header-anchor" href="#开头命令"><span>: 开头命令</span></a></h2><ul><li><code>:!</code> ：执行一个外部命令</li><li><code>:w</code> ：保存旧文件/新建新文件</li><li><code>:e</code> ：打开文件</li><li><code>:bd!</code> ：删除当前缓冲区</li></ul><p>用 v 进入可视状态后，选中指定区域，再输入 :w FILENAME 可将此区域保存到文件 FILENAME 中。</p><p><code>:r FILENAME</code> 取回磁盘文件 FILENAME 并将其插入当前缓冲区的光标位置之后，r 是 retrieve。</p><h2 id="大写字母" tabindex="-1"><a class="header-anchor" href="#大写字母"><span>大写字母</span></a></h2><ul><li><code>A</code> ：在<strong>行尾插入</strong></li><li><code>R</code> ：Vim 的替换状态，<strong>连续替换</strong>从光标开始的字符</li></ul><h2 id="复制" tabindex="-1"><a class="header-anchor" href="#复制"><span>复制</span></a></h2><ul><li><code>yy</code> ：复制一行</li><li><code>yw</code> ：<strong>复制一个单词</strong></li></ul><h1 id="vim-user-文档" tabindex="-1"><a class="header-anchor" href="#vim-user-文档"><span>Vim user 文档</span></a></h1><p>原文链接：<a href="https://www.spacemacs.org/doc/VIMUSERS.html" target="_blank" rel="noopener noreferrer">戳这</a>。该文档用于为 Vim 用户更好理解 Emacs 的各种概念。</p><h2 id="正如-vim" tabindex="-1"><a class="header-anchor" href="#正如-vim"><span>正如 Vim</span></a></h2><p>正如 Vim 有各种编辑模式，Spacemacs 用状态来区分不同文件和启用不同功能。一个 major-mode 对应一个文件类型，故一个缓冲区只能有一个 major-mode。要丰富该缓冲区的功能，就要用到各种 minor-mode。</p><p>正如 Vim 有各种插件可供安装，Emacs 使用 layer 。相比于 Vim 插件是一个个软件包，Emacs 的 layer 更像是整合包，里面有一组与 layer 关系密切的软件包。当然，Emacs 也提供像 Vim 一样安装单个软件包。</p><p>正如 Vim 有缓冲区，Emacs 也有，并且与缓冲区相关的快捷键都以 <code>&lt;SPC&gt; b</code> 为前缀：</p><ul><li><code>&lt;SPC&gt; b b</code> ：打开缓冲区列表</li><li><code>&lt;SPC&gt; b n</code> / <code>:bnext</code> ：切换到下个缓冲区，n 是 next</li><li><code>&lt;SPC&gt; b p</code> / <code>:bprevious</code> ：切换到上个缓冲区，p 是 previous</li><li><code>&lt;SPC&gt; b d</code> / <code>:bdelete</code> ：关闭当前缓冲区，d 是 delete</li><li><code>&lt;SPC&gt; b C-d</code> ：关闭除当前缓冲区外的所有缓冲区</li></ul><p>正如 Vim 有分屏，Emacs 也有类似的概念：窗格。与窗格相关的快捷键都以 <code>&lt;SPC&gt; w</code> 为前缀：</p><ul><li><code>&lt;SPC&gt; w v</code> / <code>:vsplit</code> ：向右分屏</li><li><code>&lt;SPC&gt; w s</code> / <code>:split</code> ：向下分屏</li><li><code>&lt;SPC&gt; w h/j/k/l</code> ：光标在窗格之间移动</li><li><code>&lt;SPC&gt; w H/J/K/L</code> ：移动窗格</li></ul><h2 id="帮助文档" tabindex="-1"><a class="header-anchor" href="#帮助文档"><span>帮助文档</span></a></h2><table><thead><tr><th>按键绑定</th><th>功能</th></tr></thead><tbody><tr><td><code>&lt;SPC&gt; h d f</code></td><td>查看函数</td></tr><tr><td><code>&lt;SPC&gt; h d k</code></td><td>查看按键绑定</td></tr><tr><td><code>&lt;SPC&gt; h d v</code></td><td>查看变量</td></tr><tr><td><code>&lt;SPC&gt; h &lt;SPC&gt;</code></td><td>列出所有 layer 文档</td></tr><tr><td><code>&lt;SPC&gt; &lt;f1&gt;</code></td><td>搜索命令、函数、变量并显示其文档</td></tr><tr><td><code>&lt;SPC&gt; ?</code></td><td>列出所有按键绑定</td></tr></tbody></table><p><code>&lt;SPC&gt; h &lt;SPC&gt;</code> 这个快捷键可以查看 Spacemacs 官网上几乎所有的文档，实现使用过程中随时查阅的效果，不用离开 Emacs。</p><h2 id="emacs-正则表达式" tabindex="-1"><a class="header-anchor" href="#emacs-正则表达式"><span>Emacs 正则表达式</span></a></h2><p>在正则表达式方面，Emacs 和 Vim 区别很大，以至于有人做了个工具，用于两种正则表达式互相转换，比如 <a href="https://github.com/joddie/pcre2el" target="_blank" rel="noopener noreferrer">pcre2el</a>。</p><h2 id="emacs-lisp" tabindex="-1"><a class="header-anchor" href="#emacs-lisp"><span>Emacs Lisp</span></a></h2><h3 id="设置变量" tabindex="-1"><a class="header-anchor" href="#设置变量"><span>设置变量</span></a></h3><p><code>(setq variable value)</code></p><div class="language-elisp line-numbers-mode" data-highlighter="shiki" data-ext="elisp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-elisp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">setq</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> variable1 </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">t</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> ; True</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      variable2 </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">nil</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> ; False</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      variable3 &#39;(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;A&quot;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;list&quot;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;of&quot;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;things&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="绑定快捷键" tabindex="-1"><a class="header-anchor" href="#绑定快捷键"><span>绑定快捷键</span></a></h3><p><code>(define-key map new-keybinding function)</code> ：</p><div class="language-elisp line-numbers-mode" data-highlighter="shiki" data-ext="elisp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-elisp"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;; Map H to go to the previous buffer in normal mode</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">define-key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> evil-normal-state-map (</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">kbd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;H&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">&#39;previous-buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>要映射 <code>&lt;Leader&gt;</code> 快捷键绑定，使用 spacemacs/set-leader-keys 函数 <code>(spacemacs/set-leader-keys key function)</code> ：</p><div class="language-elisp line-numbers-mode" data-highlighter="shiki" data-ext="elisp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-elisp"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;; Map killing a buffer to &lt;Leader&gt; b c</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(spacemacs/set-leader-keys </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;bc&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &#39;kill-current-buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;; Map opening a link to &lt;Leader&gt; o l only in org-mode (works for any major-mode)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(spacemacs/set-leader-keys-for-major-mode </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">&#39;org-mode</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;ol&quot;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &#39;org-open-at-point</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将按键绑定到宏上：</p><div class="language-elisp line-numbers-mode" data-highlighter="shiki" data-ext="elisp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-elisp"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;; 等同于 nmap &lt;S-Enter&gt; O&lt;Esc&gt;j</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">define-key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> evil-normal-state-map (</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">kbd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;S-&lt;return&gt;&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) (</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">kbd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;O &lt;escape&gt; j&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="定义函数" tabindex="-1"><a class="header-anchor" href="#定义函数"><span>定义函数</span></a></h3><div class="language-elisp line-numbers-mode" data-highlighter="shiki" data-ext="elisp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-elisp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">defun</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> func-name (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">arg1</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> arg2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  &quot;docstring&quot;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  ;; Body</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  )</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;; Calling a function</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(func-name arg1 arg2)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="软件包" tabindex="-1"><a class="header-anchor" href="#软件包"><span>软件包</span></a></h3><p>在 <code>dotspacemacs/layers</code> 函数中：</p><ul><li>变量 <code>dotspacemacs-additional-packages</code> 负责安装软件包</li><li>变量 <code>dotspacemacs-excluded-packages</code> 负责卸载软件包</li><li>变量 <code>dotspacemacs-configuration-layers</code> 负责激活 layer</li></ul><p>有关如何创建自己的 layer，这需要单独拿出来讲。<s>我暂时不会</s></p><p>Spacemacs 使用 <code>use-package</code> 管理包的加载：</p><div class="language-elisp line-numbers-mode" data-highlighter="shiki" data-ext="elisp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-elisp"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;; use-package 模板</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;; :defer t 表示延迟加载包</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">use-package</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> package-name</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  :defer</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">;; 加载顺序是，:init -&gt; the package -&gt; :config </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">use-package</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> package-name</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  :defer</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> t</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  :init</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  ;; 设置变量</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">setq</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> variable1 </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> variable2 </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">nil</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  ;; 定义函数</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">defun</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> foo ()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    (</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">message</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&quot; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello, World!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  :config</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  ;; Calling a function that is defined when the package loads</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  (function-defined-when-package-loads))</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="常用调整" tabindex="-1"><a class="header-anchor" href="#常用调整"><span>常用调整</span></a></h2><h3 id="自动恢复上次会话" tabindex="-1"><a class="header-anchor" href="#自动恢复上次会话"><span>自动恢复上次会话</span></a></h3><p>Spacemacs 在重新打开时不会自动恢复窗口和缓冲区。如果经常使用 Vim 会话，可以将 <code>dotspacemacs-auto-resume-layouts</code> 设置为 <code>t</code> 。</p><h3 id="使用可视行进行导航" tabindex="-1"><a class="header-anchor" href="#使用可视行进行导航"><span>使用可视行进行导航</span></a></h3><p>Spacemacs 使用 Vim 的默认设置，按实际行进行导航，即使这些行已被折行。若希望 <code>j</code> 和 <code>k</code> 的行为类似于 <code>g j</code> 和 <code>g k</code> ，请添加以下内容：</p><div class="language-elisp line-numbers-mode" data-highlighter="shiki" data-ext="elisp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-elisp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">define-key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> evil-normal-state-map (</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">kbd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;j&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">&#39;evil-next-visual-line</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">define-key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> evil-normal-state-map (</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">kbd</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;k&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">&#39;evil-previous-visual-line</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="尾声" tabindex="-1"><a class="header-anchor" href="#尾声"><span>尾声</span></a></h1><p>接下来是更完整的 <a href="https://www.spacemacs.org/doc/DOCUMENTATION.html" target="_blank" rel="noopener noreferrer">Spacemacs documentation</a>，Vim user 文档终究只是用来过渡的。</p>`,60))])}const o=e(h,[["render",p]]),g=JSON.parse('{"path":"/tools/note/Evil%20vim%20%E4%B8%8B%E7%9A%84%20Spacemacs.html","title":"Evil vim 下的 Spacemacs","lang":"zh-CN","frontmatter":{"title":"Evil vim 下的 Spacemacs","date":"2025-09-21T00:00:00.000Z","tags":["编辑器","Emacs"],"category":["代码效率"],"isOriginal":"true","description":"Evil 是一个强大的 Vim 模拟，可以让 Vim 用户更容易过渡到 Emacs 使用上。从我个人使用体验来看，Vim 的模式设计十分好用，快捷键也更加精简，比如 h、j、k、l 移动方式怎么看都要比 C-b C-p C-n C-f 好使。能把 Vim 知识迁移过来重复利用，也是一方面原因。","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Evil vim 下的 Spacemacs\\",\\"image\\":[\\"https://vip.123pan.cn/1844935313/obsidian/20250922090103771.png\\"],\\"datePublished\\":\\"2025-09-21T00:00:00.000Z\\",\\"dateModified\\":\\"2025-09-22T15:13:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"庸碌无常\\",\\"url\\":\\"https://pluinyiasnhg.top\\"}]}"],["meta",{"property":"og:url","content":"https://pluinyiasnhg.top/tools/note/Evil%20vim%20%E4%B8%8B%E7%9A%84%20Spacemacs.html"}],["meta",{"property":"og:site_name","content":"庸碌无常的博客"}],["meta",{"property":"og:title","content":"Evil vim 下的 Spacemacs"}],["meta",{"property":"og:description","content":"Evil 是一个强大的 Vim 模拟，可以让 Vim 用户更容易过渡到 Emacs 使用上。从我个人使用体验来看，Vim 的模式设计十分好用，快捷键也更加精简，比如 h、j、k、l 移动方式怎么看都要比 C-b C-p C-n C-f 好使。能把 Vim 知识迁移过来重复利用，也是一方面原因。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://vip.123pan.cn/1844935313/obsidian/20250922090103771.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-22T15:13:02.000Z"}],["meta",{"property":"article:tag","content":"Emacs"}],["meta",{"property":"article:tag","content":"编辑器"}],["meta",{"property":"article:published_time","content":"2025-09-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-22T15:13:02.000Z"}]]},"git":{"createdTime":1758467188000,"updatedTime":1758553982000,"contributors":[{"name":"pluinyiasnhg","username":"pluinyiasnhg","email":"pluinyiasnhg@gmail.com","commits":2,"url":"https://github.com/pluinyiasnhg"}]},"readingTime":{"minutes":5.54,"words":1663},"filePathRelative":"tools/note/Evil vim 下的 Spacemacs.md","excerpt":"\\n<p>Evil 是一个强大的 Vim 模拟，可以让 Vim 用户更容易过渡到 Emacs 使用上。从我个人使用体验来看，Vim 的模式设计十分好用，快捷键也更加精简，比如 <code>h、j、k、l</code> 移动方式怎么看都要比 <code>C-b C-p C-n C-f</code> 好使。能把 Vim 知识迁移过来重复利用，也是一方面原因。</p>\\n","autoDesc":true}');export{o as comp,g as data};
